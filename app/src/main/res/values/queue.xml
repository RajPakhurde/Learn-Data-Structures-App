<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="queue_info_1">\t Queue is an important data structure which stores its elements in an ordered manner.Take for example the analogies given below.</string>
    <string name="queue_info_2">▫️People moving on an escalator .The people who got on the escalator first will be the first one to step out of it. \n ▫️People waiting for a bus.The first person standing in the line will be the first one to get into the bus.\n ▫️People standing outside the ticketing window of a cinema hall.The first person in the line will get the ticket first and thus will be the first one to move out of it.\n ▫️Luggage kept on conveyor belts.Ths bag Which was placed first will be the first to come out at the other end.\n ▫️Cars lined for filling petrol .The car which came first will be filled first .\n ▫️Cars lined at a toll bridge.The first car to reach the bridge will be the first to leave.</string>
<!--     ImageView-->
    <string name="queue_info_3">\t In all these examples, we see that the element at the first position is served first . Whenever a new car comes to get petrol filled, it is added at the end of the line (at one end of the queue).Same is the case with queue data structure .A queue is FIFO(first in -first out) data structure in which the element that was inserted first is the first one to be taken out.The elements in a queue are added at one end called the rear and removed form the other end called front.\n \t Queue can be implemented by either using arrays or linked lists. In this section, we will see how queues are implemented using each of these data structure.</string>
    <string name="queue_info_4"><b>ARRAY REPRESENTATION OF QUEUES</b></string>
    <string name="queue_info_5">\t Queues can be easily represented using linear arrays. As stated earlier, every queue has front and rear variables that point to the position from where deletions and insertions can be done respectively. Consider a queue shown in Fig.</string>
<!--    ImageView-->
    <string name="queue_info_6">\t Here, front = 0 and rear = 5. Suppose we want to add another element with the value 45, then the rear would be incremented by 1 and the value would be stored at the position pointed by the rear. The queue after addition would be as shown in Fig.</string>
<!--    ImageVeiw-->
    <string name="queue_info_7">\t Here, front = 0 and rear = 6. Every time a new element has to be added, we repeat the same procedure.\n \t If we want to delete an element from the queue, then the value of the front will be incremented.Deletions are done from only this end of the queue. The queue after deletion will be as shown in Fig.</string>
<!--    ImageView-->
    <string name="queue_info_8">\t Here, front = 1 and rear = 6.\n \t However, before inserting an element in the queue, we must check for overflow conditions. An overflow will occur when we try to insert an element into a queue that is already full. When Rear = MAX-1, where MAX is the size of the queue, we have an overflow condition. Note that we have written MAX 1, because the index starts from 0. \n \t Similarly, before deleting an element from the queue, we must check for underflow conditions. An underflow condition occurs when we try to delete an element from a queue that is already empty. If front -1 and rear -1, it means there is no element in the queue. Let us now look at Figs which shows the algorithms to insert and delete an element from a queue.</string>
    <!--   ImageView-->
    <string name="queue_info_9">\t Figure shows the algorithm to insert an element in the queue. In Step 1, we first check for the overflow condition. In Step 2, we check if the queue is empty. In case the queue is initially empty, then the value of front and rear is set to zero, so that the new value can be stored at the 0th location. Otherwise, if the queue already has some values, then the REAR is incremented so that it points to the next free location in the array. In Step 3, the value is stored in the queue array at the location pointed by the REAR.</string>
    <string name="queue_info_10"><b>OPERATIONS ON A QUEUE</b></string>
    <string name="queue_info_11">\t A queue has two basic operations: insert and delete. The insert operation adds an element to the end of the queue of the stack and the delete operation removes the element from the front or the start of the queue. Apart from this, there is another operation Peek which returns the value of the first element of the queue. Consider the linked queue shown in Fig.</string>
<!--    ImageView-->
    <string name="queue_info_12"><b>INSERT OPERATION:</b></string>
    <string name="queue_info_13">\t The insert operation is used to insert an element into the queue. The new element is added as the last element of the queue. Consider the linked queue shown in Fig.</string>
    <!--    ImageView-->
    <string name="queue_info_14">\t To insert an element with the value 9, we first check if FRONT-NULL. If the condition holds, then the queue is empty. So, we allocate memory for a new node, store the value in its data part and NULL in its next part. The new node will then be called the FRONT. However, if FRONT 1 NULL, then we will insert the new node at the beginning of the linked stack and name this new node as TOP. Thus, the updated stack becomes as shown in Fig.</string>
    <!--    ImageView-->
    <string name="queue_info_15">\t Figure shows the algorithm to insert an element in the circular queue. In Step 1, the memory is allocated for the new node. In Step 2, the DATA part of the new node is initialized with the value to be stored in the node. In Step 3, we check if the new node is the first node of the linked queue. This is done by checking if FRONT = NULL. In case the if statement evaluates to true, then the new node is tagged as FRONT as well as REAR. Also NULL is stored in the NEXT part of the node (which is also the FRONT and the REAR node). However, if the new node is not the first node in the list, then it is added at the REAR end of the linked queue (or the last node of the queue).</string>
    <!--    ImageView-->
    <string name="queue_info_16"><b>DELETE OPERATION:</b></string>
    <string name="queue_info_17">\t The delete operation is used to delete the element that was first inserted in a queue. That is, the delete operation deletes the element whose address is stored in the FRONT. However, before deleting the value, we must first check if FRONT-NULL, because if this is the case, then the queue is empty and no more deletions can be done. If an attempt is made to delete a value from a queue that is already empty, an UNDERFLOW message is printed. Consider the queue shown in Fig.</string>
    <!--    ImageView-->
    <string name="queue_info_18">\t To delete an element, we first check if FRONT=NULL. If the condition is false, then we delete the first node pointed by FRONT. The FRONT will now point to the second element of the linked queue. Thus, the updated queue becomes as shown in Fig.</string>
    <!--    ImageView-->
    <string name="queue_info_19">\t Figure shows the algorithm to delete an element from a linked queue. In Step 1, we first check for the underflow condition. If the condition is true, then an appropriate message is displayed, otherwise in Step 2, we use a PTR that points to FRONT. In Step 3, FRONT is made to point to the next node in sequence. In Step 4, the free pool.</string>
    <!--    ImageView-->
</resources>